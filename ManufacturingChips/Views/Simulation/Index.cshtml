@model ManufacturingChips.Models.SimulationView
@{
ViewData["Title"] = "Симуляція виробництва";
}

<h1>Налаштування та запуск симуляції</h1>

<form id="simForm" class="row g-3" onsubmit="return false;">
    <div class="col-md-2">
        <label asp-for="LinesCount">Ліній</label>
        <input asp-for="LinesCount" class="form-control" type="number" min="1" />
    </div>
    <div class="col-md-2">
        <label asp-for="MachinesPerLine">Машини/лінію</label>
        <input asp-for="MachinesPerLine" class="form-control" type="number" min="1" />
    </div>
    <div class="col-md-3">
        <label asp-for="ShiftDurationSeconds">Тривалість зміни (сек)</label>
        <input asp-for="ShiftDurationSeconds" class="form-control" type="number" min="1" />
    </div>
    <div class="col-auto align-self-end">
        <button id="applyBtn" name="action" value="apply" class="btn btn-secondary">Застосувати</button>
        <button id="startBtn" type="button" class="btn btn-success">Почати</button>
    </div>
</form>

<!-- NEW: Timer display -->
<div class="mt-3">
    <h4>Час до закінчення зміни: <span id="timeDisplay">--:--</span></h4>
</div>

<form id="stopForm" class="mt-2" onsubmit="return false;">
    <button id="stopBtn" type="button" class="btn btn-danger" disabled>Зупинити</button>
</form>

<hr />

<div class="row">
    <div class="col-md-6">
        <h2>Анімація</h2>
        <div id="animation" class="animation-container">
            @for (int line = 1; line <= Model.LinesCount; line++)
            {
            <div class="line" id="line@line">
                <div class="queue" id="queue@line"></div>
                @for (int m = 0; m < Model.MachinesPerLine; m++)
                {
                <div class="machine" data-index="@m">M@(m+1)</div>
                }
            </div>
            }
        </div>

        <h2 class="mt-4">Лог подій</h2>
        <ul id="logList" class="list-unstyled" style="max-height:300px; overflow:auto"></ul>
    </div>

    <div class="col-md-6">
        <h2>Статистика</h2>
        <div id="statsContainer">
            <p>Поки статистики немає.</p>
        </div>
    </div>
</div>

@section Styles {
<style>
    .animation-container { display:flex; flex-direction:column; gap:30px; }
    .line {
        position:relative;
        display:grid;
        grid-template-columns:60px repeat(@Model.MachinesPerLine,80px) 1fr;
        column-gap:30px;
        align-items:center;
        padding:10px;
        background:#f9fbfc;
        border:1px solid #cfd8dc;
        border-radius:6px;
        height:100px;
    }
    .queue {
        grid-column:1;
        width:60px; height:60px;
        background:#fff; border:2px dashed #90a4ae;
        border-radius:4px;
        display:flex; flex-direction:column;
        align-items:center; justify-content:start;
        padding:4px; overflow-y:auto;
    }
    .queue .chip {
        width:20px; height:20px; margin:2px 0;
        background:linear-gradient(135deg,#ffeb3b 25%,#fbc02d 75%);
        border:1px solid #f57f17; border-radius:3px;
    }
    .machine {
        width:80px; height:60px;
        background:#eceff1; border:2px solid #607d8b;
        border-radius:4px; display:flex;
        align-items:center; justify-content:center;
        font-weight:bold; color:#37474f;
    }
    .product {
        position:absolute; width:24px; height:24px;
        background:linear-gradient(135deg,#8bc34a 25%,#558b2f 75%);
        border:1px solid #33691e; border-radius:4px;
        top:50%; transform:translateY(-50%);
        transition:left 0.6s ease-in-out;
    }
</style>
}

@section Scripts {
<script>
    let intervals = [];
    let pollInterval = null;
    let timerInterval = null;
    let shiftEndTime = null;

    // Log helper
    function logEvent(msg) {
        const ul = document.getElementById("logList");
        const time = new Date().toLocaleTimeString();
        const li = document.createElement("li");
        li.textContent = `[${time}] ${msg}`;
        ul.prepend(li);
    }

    // Start the chip‐spawn + move animation
    function startAnimation() {
        document.querySelectorAll(".line").forEach((lineElem, idx) => {
            const queueBox = lineElem.querySelector(".queue");
            const machines = [...lineElem.querySelectorAll(".machine")];
            const rect = lineElem.getBoundingClientRect();
            const centers = machines.map(m => {
                const r = m.getBoundingClientRect();
                return r.left + r.width/2 - rect.left;
            });
            const finishX = lineElem.clientWidth - 20;

            const iv = setInterval(() => {
                // enqueue
                const chip = document.createElement("div");
                chip.className = "chip";
                queueBox.appendChild(chip);
                logEvent(`Лінія ${idx+1}: мікросхема в чергу`);

                // animate
                const product = document.createElement("div");
                product.className = "product";
                const startX = queueBox.offsetLeft + queueBox.offsetWidth + 10;
                product.style.left = startX + "px";
                lineElem.appendChild(product);

                const path = [startX, startX + 10, ...centers, finishX];
                let step = 0;
                function move() {
                    if (step === 1 && queueBox.firstElementChild) {
                        queueBox.removeChild(queueBox.firstElementChild);
                        logEvent(`Лінія ${idx+1}: вийшла з черги`);
                    }
                    if (step < path.length) {
                        product.style.left = path[step] + "px";
                        step++;
                        setTimeout(move, 600);
                    } else {
                        product.remove();
                        logEvent(`Лінія ${idx+1}: завершено`);
                    }
                }
                move();
            }, 1200 + idx * 300);

            intervals.push(iv);
        });
    }

    // Stop both animation and backend
    async function handleStop() {
        // clear spawn intervals
        intervals.forEach(clearInterval);
        intervals = [];

        // stop timer
        clearInterval(timerInterval);
        document.getElementById("timeDisplay").textContent = "00:00";

        // disable Stop button
        document.getElementById("stopBtn").disabled = true;

        // tell backend to cancel immediately
        await fetch('@Url.Action("Stop","Simulation")', { method: 'POST' });
    }

    // Called when timer hits zero
    function handleTimeUp() {
        handleStop();
    }

    // Update countdown display each second
    function updateTimer() {
        const msLeft = shiftEndTime - Date.now();
        if (msLeft <= 0) {
            document.getElementById("timeDisplay").textContent = "00:00";
            clearInterval(timerInterval);
            handleTimeUp();
        } else {
            const secs = Math.floor(msLeft/1000);
            const m = String(Math.floor(secs/60)).padStart(2,'0');
            const s = String(secs%60).padStart(2,'0');
            document.getElementById("timeDisplay").textContent = `${m}:${s}`;
        }
    }

    // Poll server for IsRunning → when false, fetch stats
    function startPolling() {
        pollInterval = setInterval(async () => {
            const resp = await fetch('@Url.Action("IsRunning","Simulation")');
            const running = await resp.json();
            if (!running) {
                clearInterval(pollInterval);
                // ensure animations are stopped
                intervals.forEach(clearInterval);
                intervals = [];
                clearInterval(timerInterval);
                fetchStats();
                document.getElementById("startBtn").disabled = false;
                document.getElementById("stopBtn").disabled = true;
            }
        }, 1000);
    }

    // Render the detailed machine‐level stats
    function renderStats(data) {
        const div = document.getElementById("statsContainer");
        if (!data.stats || !data.stats.length) {
            div.innerHTML = "<p>Дані статистики відсутні.</p>";
            return;
        }
        let html = `<p><strong>Згенеровано продуктів:</strong> ${data.total}</p>`;
        data.stats.forEach(line => {
            html += `<h3>Лінія ${line.lineNumber}</h3>`;
            html += `<table class="table table-striped">
<thead>
<tr>
  <th>Машина</th>
  <th>Завантаження (%)</th>
  <th>Сер. час в черзі (с)</th>
  <th>Сер. час обслуг. (с)</th>
  <th>Макс. черга</th>
  <th>Оброблено</th>
</tr>
</thead><tbody>`;
            line.machineStats.forEach(m => {
                html += `<tr>
  <td>${m.machineIndex}</td>
  <td>${(m.utilization*100).toFixed(2)}</td>
  <td>${m.averageQueueTime.toFixed(2)}</td>
  <td>${m.averageServiceTime.toFixed(2)}</td>
  <td>${m.maxQueueLength}</td>
  <td>${m.processedProducts}</td>
</tr>`;
            });
            html += `</tbody></table>`;
        });
        div.innerHTML = html;
    }

    async function fetchStats() {
        const resp = await fetch('@Url.Action("GetStats","Simulation")');
        const data = await resp.json();
        renderStats(data);
    }

    // Start button wiring
    document.getElementById("startBtn").addEventListener("click", async () => {
        const form = document.getElementById("simForm");
        const payload = {
            LinesCount: +form.elements["LinesCount"].value,
            MachinesPerLine: +form.elements["MachinesPerLine"].value,
            ShiftDurationSeconds: +form.elements["ShiftDurationSeconds"].value
        };

        await fetch('@Url.Action("StartSimulation","Simulation")', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        // UI state
        document.getElementById("startBtn").disabled = true;
        document.getElementById("stopBtn").disabled = false;

        // Set up countdown
        shiftEndTime = Date.now() + payload.ShiftDurationSeconds * 1000;
        updateTimer();
        timerInterval = setInterval(updateTimer, 1000);

        startAnimation();
        startPolling();
    });

    document.getElementById("stopBtn").addEventListener("click", handleStop);

</script>
}
